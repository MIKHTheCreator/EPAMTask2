Для поддержки многопоточного программирования в Java предусмотрен класс и интерфейс .

В каких случаях следует отдать предпочтение расширению класса Thread над реализацией интерфейса Runnable?

Покажите, как с помощью метода j oin () можно организовать ожидание завершения потокового объекта MyThrd.

Покажите, как установить приоритет потока MyThrd на три уровня выше нормального приоритета.

Что произойдет, если в объявлении метода указать ключевое слово synchronized?

Методы wait () и notify () служат для __ .

Внесите в класс TickTock изменения для организации настоящего отчета времени. Первую половину секунды должен занимать вывод на экран слова "Tick", а вторую — вывод слова "Tock". Таким образом, сообщение "Tick-Tock" должно соответствовать одной секунде отсчитываемого времени. (Время переключения контекстов можно не учитывать.)

Почему в новых программах на Java не следует применять методы suspend(), resume() и stop()?

С помощью какого метода из класса Thread можно получить имя потока?

Какое значение возвращает метод isAlive () ?

Попытайтесь самостоятельно реализовать средства синхронизации в классе Queue, разработанном в предыдущих главах. В результате доработки класс должен действовать правильно, когда он используется для многопоточной обработки.

Глава 12 Перечисления, автоупаковка, статический импорт и аннотации

Основные навыки и понятия

Представление о перечислениях

Применение свойств перечислений, основанных на классах

Применение методов values () и valueof () к перечислениям

Создание перечислений с конструкторами, переменными экземпляра и методами

Применение методов ordinal () и compareTo (), наследуемых перечислениями от класса Enum

Использование оболочек типов Java

Основные положения об автоупаковке и автораспаковке

Применение автоупаковки в методах

Употребление автоупаковки в выражениях

Применение статического импорта

Основные положения об аннотациях

В этой главе рассматриваются четыре относительно новые языковые средства Java: перечислинения, автоупаковка, статический импорт и аннотации. И хотя ни одно из них не вошло в первоначальное описание Java, каждое из них расширяет возможности и область применения этого языка программирования. Так, перечисления и автоупаковка удовлетворяют давно назревшим потребностям, статический импорт упрощает применение статических членов класса, тогда как аннотации расширяют виды информации, которую можно встраивать в исходный файл. А сообща все эти средства обеспечивают более совершенное решение насущных задач программирования. В этой главе рассматриваются также оболочки типов Java.Перечисления

Несмотря на то что перечисления применяются во многих языках программирования, в первоначальном описании Java они не поддерживалась. Это, в частности, объясняется тем, что перечисление является скорее удобным, чем обязательным языковым средством. Но со временем программирующие на Java все чаще стали ощущать потребность в перечислениях, потому что с их помощью они могли реализовать структурно изящные решения многих задач программирования. И эта потребность была учтена в версии JDK 5, начиная с которой перечисления внедрены в Java.

В простейшем виде перечисление представляет собой список именованных констант, определяющих новый тип данных. Объект перечислимого типа может принимать лишь значения, содержащиеся в списке. Таким образом, перечисления предоставляют возможность точно определить новый тип данных, имеющий строго фиксированный ряд допустимых значений.

В повседневной жизни перечисления встречаются довольно часто. Например, к ним можно отнести ряд монет, имеющих хождение в стране. А месяцы года и дни недели перечисляются по названиям.

С точки зрения программирования перечисления оказываются удобными в тех случаях, когда требуется определить ряд значений, обозначающих совокупность элементов. Например, с помощью перечисления можно представить набор кодов состояния (успешное завершение, ошибка, необходимость повторной попытки). Конечно, такие значения можно определить и с помощью констант типа final, но перечисления обеспечивают более структурированный подход к решению подобной задачи.Основные положения о перечислениях

Для создания перечисления служит ключевое слово enum. Ниже приведен пример простого перечисления разных видов транспортных средств.// Перечисление видов транспортных средств,enum Transport { CAR, TRUCK, AIRPLANE, TRAIN, BOAT}

Идентификаторы CAR, TRUCK и так далее называются константами перечислимого типа. Каждый из них автоматически неявно объявляется как открытый (public), статический (static) член перечисления Transport. Тип этих констант соответствует типу перечисления (в данном случае — Transport). В терминологии Java подобные константы называются самотипизированными (приставка “само” означает, что в качестве типа константы принимается тип перечисления).

Определив перечисление, можно создать переменную данного типа. Но, несмотря на то, что перечисление определяется как тип класса, получить экземпляр объекта типа enum с помощью оператора new нельзя. Переменная перечислимого типа создается подобно переменной простого типа. Например, для объявления переменной tp упомянутого выше перечислимого типа Transport служит следующее выражение:Transport tp;

Переменная tp относится к типу Transport, и поэтому ей можно присваивать только те значения, которые определены в данном перечислении. Например, в следующей строке кода переменной tp присваивается значение AIRPLANE:tp = Transport.AIRPLANE;

Обратите внимание на то, что идентификатор AIRPLANE полностью определяется как относящийся к типу Transport.

Для проверки равенства констант перечислимого типа служит оператор сравнения =. Например, в приведенной ниже строке кода содержимое переменной tp сравнивается с константой TRAIN,if(tp == Transport.TRAIN) // ...

Перечислимые значения можно также использовать в операторе switch. Очевидно, что в ветвях case этого оператора могут присутствовать только константы того же самого перечислимого типа, что и в выражении switch. Например, следующий фрагмент кода составлен правильно:// Применение перечисления для управления оператором switch,switch(tp) {case CAR: // ...case TRUCK: // ...

Как видите, в ветвях case используются константы без полного определения имени типа. Например, вместо Transport. TRUCK указано просто TRUCK. Это допустимо потому, что перечислимый тип в выражении switch неявно определяет тип констант в ветвях case. Более того, если попытаться указать тип константы явно, при компиляции возникнет ошибка.

При отображении константы перечислимого типа, например, с помощью метода println (), выводится ее имя. Так, в результате выполнения следующего оператора отобразится имя BOAT:System.out.println(Transport.BOAT);

Ниже приведен пример программы, демонстрирующий все особенности применения перечисления Transport.// Особенности применения перечисления Transport.// Объявление перечисления.enum Transport {CAR, TRUCK, AIRPLANE, TRAIN, BOAT}class EnumDemo { public static void main(String args[]) { // Объявление ссылки на перечисление Transport. Transport tp; // Присваивание переменной tp константы AIRPLANE. tp = Transport.AIRPLANE; // вывести перечислимое значение System.out.println("Value of tp: " + tp) ; System.out.println(); tp = Transport.TRAIN; // Проверка равенства двух объектов типа Transport. if(tp == Transport.TRAIN) // сравнить два перечислимых значения System.out.println("tp contains TRAIN.n"); // Использование перечисления для управления оператором switch. switch(tp) { case CAR: System.out.println("A car carries people."); break; case TRUCK: System.out.println("A truck carries freight."); break; case AIRPLANE: System.out.println("An airplane flies."); break; case TRAIN: System.out.println("A train runs on rails."); break; case BOAT: System.put.println("A boat sails on water."); break; } }}
